<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Matrix Multiplication (All Steps + Chart)</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    font-family: "Poppins", sans-serif;
    background: linear-gradient(to right, #eef2ff, #e0f2fe);
    margin: 0;
    padding: 20px;
  }
  .container {
    max-width: 1150px;
    margin: auto;
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
  h1 {
    text-align: center;
    color: #1e3a8a;
  }
  .input-section, .result-section {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
  }
  .card {
    background: #f9fafb;
    border-radius: 10px;
    padding: 15px;
    flex: 1 1 300px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  .card h3 {
    margin-top: 0;
    color: #1e40af;
  }
  table {
    border-collapse: collapse;
    margin: 10px 0;
  }
  td {
    border: 1px solid #ccc;
    padding: 4px 8px;
    text-align: center;
    font-size: 14px;
  }
  input[type="number"] {
    width: 60px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 6px;
  }
  input.matrix-cell {
    width: 45px;
    padding: 3px;
    border: 1px solid #aaa;
    border-radius: 4px;
    text-align: center;
  }
  button {
    background-color: #2563eb;
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    cursor: pointer;
    margin: 3px;
    transition: 0.2s;
  }
  button:hover {
    background-color: #1e40af;
  }
  .logs {
    background: #f1f5f9;
    padding: 10px;
    border-radius: 6px;
    max-height: 200px;
    overflow-y: auto;
    font-size: 14px;
  }
  .steps {
    background: #f0f9ff;
    padding: 8px;
    border-left: 4px solid #0ea5e9;
    margin-top: 8px;
    border-radius: 4px;
    font-size: 13px;
  }
  @keyframes flash {
    from { background-color: #dbeafe; }
    to { background-color: white; }
  }
  .flash {
    animation: flash 1s ease;
  }
  canvas {
    margin-top: 20px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Matrix Multiplication (Show Steps + Performance Chart)</h1>

  <div class="input-section">
    <div class="card">
      <h3>Matrix Sizes</h3>
      <div>
        <b>Matrix A:</b> Rows 
        <input id="rowsA" type="number" value="3" min="1">
        Cols 
        <input id="colsA" type="number" value="3" min="1">
      </div>
      <div>
        <b>Matrix B:</b> Rows 
        <input id="rowsB" type="number" value="3" min="1">
        Cols 
        <input id="colsB" type="number" value="3" min="1">
      </div>
      <br>
      <button onclick="createInputMatrices()">Create Input Matrices</button>
      <button onclick="clearAll()">Clear Results</button>
    </div>

    <div class="card">
      <h3>Operations</h3>
      <button onclick="multiplySingle()">Single-threaded</button>
      <button onclick="multiplyPerRow()">Multithreaded (per row)</button>
      <button onclick="multiplyPerCell()">Multithreaded (per cell)</button>
      <p style="font-size:13px;color:#555;">Note: Per-cell mode creates many workers; avoid large matrices.</p>
    </div>
  </div>

  <div class="result-section">
    <div class="card" id="matrixAContainer"></div>
    <div class="card" id="matrixBContainer"></div>
    <div class="card" id="resultContainer"></div>
  </div>

  <div class="card">
    <h3>Performance Logs</h3>
    <div class="logs" id="logs"></div>
  </div>

  <div class="card">
    <h3>Performance Comparison Chart</h3>
    <canvas id="performanceChart" height="120"></canvas>
  </div>
</div>

<script>
let A = [], B = [];
let chartData = {
  labels: ["Single-threaded", "Per-row", "Per-cell"],
  times: [0, 0, 0]
};
let chart;

// Initialize Chart
function initChart() {
  const ctx = document.getElementById("performanceChart").getContext("2d");
  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: 'Execution Time (ms)',
        data: chartData.times,
        backgroundColor: ['#2563eb', '#059669', '#d97706']
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: { beginAtZero: true }
      },
      plugins: {
        legend: { display: false }
      }
    }
  });
}

function updateChart(index, time) {
  chartData.times[index] = time;
  chart.update();
}

function createInputMatrices() {
  const rA = +document.getElementById("rowsA").value;
  const cA = +document.getElementById("colsA").value;
  const rB = +document.getElementById("rowsB").value;
  const cB = +document.getElementById("colsB").value;

  if (cA !== rB) {
    alert("Matrix A's columns must equal Matrix B's rows!");
    return;
  }

  A = Array.from({ length: rA }, () => Array(cA).fill(0));
  B = Array.from({ length: rB }, () => Array(cB).fill(0));

  displayEditableMatrix(A, "matrixAContainer", "Matrix A");
  displayEditableMatrix(B, "matrixBContainer", "Matrix B");
  document.getElementById("resultContainer").innerHTML = "";
}

function displayEditableMatrix(matrix, containerId, label) {
  let html = `<h3>${label}</h3><table>`;
  matrix.forEach((row, i) => {
    html += "<tr>";
    row.forEach((_, j) => {
      html += `<td><input class='matrix-cell' type='number' id='${containerId}_${i}_${j}' value='0'></td>`;
    });
    html += "</tr>";
  });
  html += "</table>";
  html += `<button onclick="updateMatrix('${containerId}')">Update ${label}</button>`;
  document.getElementById(containerId).innerHTML = html;
}

function updateMatrix(containerId) {
  let target = (containerId === "matrixAContainer") ? A : B;
  for (let i = 0; i < target.length; i++) {
    for (let j = 0; j < target[0].length; j++) {
      const cell = document.getElementById(`${containerId}_${i}_${j}`);
      const val = parseFloat(cell.value);
      target[i][j] = isNaN(val) ? 0 : val;
      cell.classList.add("flash");
      setTimeout(() => cell.classList.remove("flash"), 1000);
    }
  }
  logMessage(`${containerId === "matrixAContainer" ? "Matrix A" : "Matrix B"} updated.`);
}

function logMessage(msg) {
  const logs = document.getElementById("logs");
  logs.innerHTML = `<div>${msg}</div>` + logs.innerHTML;
}

function clearAll() {
  document.getElementById("resultContainer").innerHTML = "";
  document.getElementById("logs").innerHTML = "";
  chartData.times = [0, 0, 0];
  chart.update();
}

// ------------------- SINGLE THREADED -------------------
function multiplySingle() {
  if (!A.length || !B.length) return alert("Enter matrices first!");
  const t0 = performance.now();
  const result = [];
  let steps = [];

  for (let i = 0; i < A.length; i++) {
    result[i] = [];
    for (let j = 0; j < B[0].length; j++) {
      let products = [];
      let sum = 0;
      for (let k = 0; k < B.length; k++) {
        const p = A[i][k] * B[k][j];
        products.push(`(${A[i][k]}×${B[k][j]})`);
        sum += p;
      }
      result[i][j] = sum;
      steps.push(`C[${i}][${j}] = ${products.join(" + ")} = ${sum}`);
    }
  }

  const t1 = performance.now();
  displayResult(result, "Result (Single-threaded)", steps);
  logMessage(`Single-threaded: ${(t1 - t0).toFixed(2)} ms`);
  updateChart(0, +(t1 - t0).toFixed(2));
}

// ------------------- MULTITHREADED: PER ROW -------------------
function multiplyPerRow() {
  if (!A.length || !B.length) return alert("Enter matrices first!");
  const t0 = performance.now();
  let result = Array.from({length: A.length}, () => []);
  let steps = [];
  let completed = 0;

  const workerCode = `
    onmessage = function(e) {
      const {Arow, B, rowIndex} = e.data;
      const m = B[0].length;
      const row = Array(m).fill(0);
      const stepList = [];
      for (let j=0;j<m;j++){
        let sum=0;
        let products=[];
        for(let k=0;k<Arow.length;k++){
          sum += Arow[k]*B[k][j];
          products.push("(" + Arow[k] + "×" + B[k][j] + ")");
        }
        row[j]=sum;
        stepList.push("C["+rowIndex+"]["+j+"] = "+products.join(" + ")+" = "+sum);
      }
      postMessage({rowIndex, row, stepList});
    };
  `;
  const blob = new Blob([workerCode], {type: 'application/javascript'});
  const url = URL.createObjectURL(blob);

  for (let i = 0; i < A.length; i++) {
    const worker = new Worker(url);
    worker.postMessage({Arow: A[i], B, rowIndex: i});
    worker.onmessage = function(e) {
      const {rowIndex, row, stepList} = e.data;
      result[rowIndex] = row;
      steps.push(...stepList);
      worker.terminate();
      completed++;
      if (completed === A.length) {
        const t1 = performance.now();
        displayResult(result, "Result (Per Row Workers)", steps);
        logMessage(`Per-row: ${(t1 - t0).toFixed(2)} ms`);
        updateChart(1, +(t1 - t0).toFixed(2));
      }
    };
  }
}

// ------------------- MULTITHREADED: PER CELL -------------------
function multiplyPerCell() {
  if (!A.length || !B.length) return alert("Enter matrices first!");
  const n = A.length, m = B[0].length;
  const totalCells = n * m;
  if (totalCells > 500) {
    alert("Too many workers! Use smaller matrices.");
    return;
  }
  const t0 = performance.now();
  let result = Array.from({length: n}, () => Array(m).fill(0));
  let steps = [];
  let completed = 0;

  const workerCode = `
    onmessage = function(e) {
      const {Arow, Bcol, rowIndex, colIndex} = e.data;
      let sum = 0;
      let products=[];
      for (let k=0;k<Arow.length;k++){
        sum += Arow[k]*Bcol[k];
        products.push("(" + Arow[k] + "×" + Bcol[k] + ")");
      }
      postMessage({rowIndex, colIndex, val: sum, step:"C["+rowIndex+"]["+colIndex+"] = "+products.join(" + ")+" = "+sum});
    };
  `;
  const blob = new Blob([workerCode], {type: 'application/javascript'});
  const url = URL.createObjectURL(blob);

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      const worker = new Worker(url);
      const Bcol = B.map(row => row[j]);
      worker.postMessage({Arow: A[i], Bcol, rowIndex: i, colIndex: j});
      worker.onmessage = function(e) {
        const {rowIndex, colIndex, val, step} = e.data;
        result[rowIndex][colIndex] = val;
        steps.push(step);
        worker.terminate();
        completed++;
        if (completed === totalCells) {
          const t1 = performance.now();
          displayResult(result, "Result (Per Cell Workers)", steps);
          logMessage(`Per-cell: ${(t1 - t0).toFixed(2)} ms`);
          updateChart(2, +(t1 - t0).toFixed(2));
        }
      };
    }
  }
}

function displayResult(matrix, label, steps=[]) {
  let html = `<h3>${label}</h3><table>`;
  matrix.forEach(row => {
    html += "<tr>" + row.map(v => `<td>${v}</td>`).join('') + "</tr>";
  });
  html += "</table>";

  if (steps.length) {
    const stepHTML = steps.map(s => `${s}`).join("<br>");
    html += `
      <button onclick="toggleSteps()" id="toggleBtn">Show Steps</button>
      <div class='steps' id='stepsBox' style='display:none'>
        <b>Step-by-Step Calculation:</b><br>${stepHTML}
      </div>
    `;
  }

  document.getElementById("resultContainer").innerHTML = html;
}

function toggleSteps() {
  const box = document.getElementById('stepsBox');
  const btn = document.getElementById('toggleBtn');
  if (box.style.display === 'none') {
    box.style.display = 'block';
    btn.textContent = 'Hide Steps';
  } else {
    box.style.display = 'none';
    btn.textContent = 'Show Steps';
  }
}

window.onload = initChart;
</script>
</body>
</html>
